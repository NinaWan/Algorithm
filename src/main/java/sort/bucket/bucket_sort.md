# Bucket Sort 桶排序

## 算法思想

将待排序数组中的元素根据某种映射关系分配到若干桶里，再分别对每个桶内的元素进行排序，最后将所有桶内的元素依次输出即可。

其中，映射函数的选择至关重要，它必须要确保分配到当前桶里的元素都小于分配到下一个桶里的元素，这样才能保证最后的输出是整体有序的。
同时，为了确保桶排序算法的效率，映射函数应该尽可能将待排序的数据均匀地分配到每个桶里。

## 实现方法

1. 根据数据特定确定桶的数量，或者先确定桶的容量，再根据桶的容量和数据范围计算出所需桶的数量，初始化桶数组。
2. 遍历待排序数组，将每个元素根据映射函数分配到对应的桶里。
3. 遍历桶数组，选择合适的排序算法对每个桶里的元素进行排序。
4. 依次输出每个桶里的元素。

## 复杂度分析

### 假设

* 数组长度为n，桶的数量为k，每个桶的容量为m

### 时间复杂度

桶排序的时间复杂度主要由3部分组成：

1. 遍历待排序数组，将每个元素映射到对应的桶中所需要的时间。

   映射函数的时间复杂度为O(1)，所以这部分的时间复杂度为O(n)。

2. 对每个桶里的元素进行排序的时间之和。

   这部分的时间复杂度与使用的排序算法的时间复杂度有关。
   假设使用快速排序算法，因此每个桶需要$O(m\log m)$的时间复杂度。
   总共有k个桶，所以总的时间复杂度为$O(k\times m\log m)$。

3. 依次输出桶里每个元素所需要的时间。

   显而易见，这部分的时间复杂度为O(n)。

所以，桶排序的整体时间复杂度为$O(n)+O(k\times m\log m)+O(n)=O(n+k\times m\log m)$。通常，有k=n/m，所以桶排序的时间复杂度可以简化为$O(n+n\log m)$。

**最优时间复杂度**：当m取最小值1时，时间复杂度为O(n)

**最差时间复杂度**：当m取最大值n时，时间复杂度为O(n+nlogn)=O(nlogn)

**平均时间复杂度**：$O(n+n\log m)$，m为桶的容量；也可以写成$O(n+n\log \frac{n}{k})$，k为桶的个数

### 空间复杂度

桶排序算法需要额外的空间来存储每个桶和桶内的每个元素，所以空间复杂度为O(n+k)，k为桶的个数。

## 稳定性分析

桶排序的稳定性取决于选择的桶内排序算法的稳定性。

## 扩展/优化
